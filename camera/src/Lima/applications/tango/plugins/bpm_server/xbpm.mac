#%NAME%
#  Macrocontroller to read the xbpm positions and intensity
#  
#%DESCRIPTION%
#  Macrocontroller to read the xbpms position X, Y and intensity
#%BR% Spec configuration:
#%BR% The controller xbpm must be declared in the SCALERS part
#%BR%\0
#%BR%SCALERS\0\0\0\0\0\0DEVICE\0\0ADDR\0\0<>MODE\0\0NUM\0\0\0\0<>TYPE
#%BR%\0\0\0\0YES\0\0\0\0\0\0\0xbpm\0\0ID24/xbpm/1\0\0\0\04\0\0\0\0\0\0Macro Counter
#%BR%- ADDR: tango device name gor the xbpm
#%BR%\0
#%BR%Three counters can be defined in the Scaler (Counter) Configuration
#%BR%\0
#%BR%Number\0\0\0\0\0\0Name\0\0\0Mnemonic\0\0<>Device\0\0Unit\0\0Chan\0\0<>Use\0As\0\0Scale\0Factor
#%BR%\0\0\0\010\0\0x_intens\0\0x_intens\0\0\0MAC_CNT\0\0\0\00\0\0\0\00\0\0\0\0\0counter\0\0\0\0\0\0\0\0\0\01
#%BR%\0\0\0\011\0\0\0\0\0\0\0x_x\0\0\0\0\0\0\0x_x\0\0\0MAC_CNT\0\0\0\00\0\0\0\01\0\0\0\0\0counter\0\0\0\0\0\0\0\0\0\01
#%BR%\0\0\0\012\0\0\0\0\0\0\0x_y\0\0\0\0\0\0\0x_y\0\0\0MAC_CNT\0\0\0\00\0\0\0\02\0\0\0\0\0counter\0\0\0\0\0\0\0\0\0\01
#%BR%\0
#%BR%- Unit refers to the macrocounter index in the SCALERS part
#%BR%- channel: 1 (for intensity), 2 (for X position), 3 (for Y position), 4 (FWHM X), 5 (FWHM Y)


#%END%


global xbpm_SIMUL xbpm_DEBUG xbpm_CNT[] xbpm_DEV[] xbpm_CNTNB[] xbpm_ROIDEV[]
global xbpm_STATE[]
 
#%UU%
#%MDESC% toggle the debug mode
if (!(whatis("__xbpm_debug")  & 2)) rdef __xbpm_debug \'#$*\'
def xbpm_debug '{
  if ((whatis("__xbpm_debug")>>16) <= 3) { # macro length is 3 bytes: comment
     rdef __xbpm_debug "eprint"
     print "xbpm macro debug mode is ON"
     xbpm_DEBUG = 1
  }
  else {
     rdef __xbpm_debug \'#\$*\'
     print "xbpm macro debug mode is OFF"
     xbpm_DEBUG = 0
  }
}'

#%IU% (mne, type, unit, module, chan)
#%MDESC% Called after reading the config file. If return the string ".error.",
#spec will consider the channel unusable.
def xbpm_config(mne, type, unit, module, chan)'{

   __xbpm_debug ">>> xbpm:    ",mne, type, unit, module, chan

  TANGO_ERR = ""
  if (type=="ctrl") {
    unglobal xbpm_SIMUL xbpm_STATE
    global xbpm_SIMUL[] xbpm_STATE[]
    tango_io(xbpm_ADDR, "State")
    if (TANGO_ERR){
      print_tango_err()
      return ".error."
    }
    tango_io(xbpm_ADDR,"timeout",10)
    xbpm_DEV[unit] = xbpm_ADDR
    xbpm_ROIDEV[unit] = xbpm_CONPAR["limadev"]
  }
  if (type == "cnt") {
    if (chan > 6) {
      eprintf ("Channel number %d for counter %s invalid, disabling\n", \
	chan, mne)
      return ".error."
    }
    xbpm_CNTNB[unit][chan] = cnt_num(mne)
  }
  if (type == "mot") {
    return
  }
}'

#%IU% (mne, key, p1, p2, unit)
#%MDESC% Execute the command %B%key%B% for the counter %B%mne%B%, with
#parameters %B%p1%B% and %B%p2%B% if needed. The keys used are as follows:%BR%
#%B%"start_one"%B% and %B%"prestart_all"%B% - start the counting
#Parameters: p1 - counting time.%BR%
#Parameters: p2 - 2 (count to a time preset - tcount()).%BR%
#Parameters: unit - the unit number (if me is ..).%BR%
#%B%"counts"%B% - return the current counts.
#Parameters: unit - the unit number (if mne is ..).%BR%
#%B%"get_status%B%" - only used for polling counter
#Parameters:none.%BR%
#%B%"halt_all%B%" - stop the counting and read the controller (all the
#counters in one go)
#Parameters: p1 - controller unit number.%BR%
#Return the string ".error.", spec will consider the channel unusable.
def xbpm_cmd(mne,key,p1,p2,unit)'{
local out[]

  __xbpm_debug ">>> xbpm:    ",mne, key, p1, p2, unit

  if (key == "prestart_all") {
    if (xbpm_SIMUL[unit] == 1)
      return
    _xbpmena(unit)
    TANGO_ERR = "-1"
    tango_put(xbpm_ADDR, "ExposureTime", p1)
    if (TANGO_ERR){
      _geterr(unit)
      _xbpmdisa(unit)
      return ".error."
    }
    tango_io(xbpm_ADDR,"AcquirePositions", p1)
  }

  if (key == "halt_all") {
    if ((xbpm_SIMUL[p1] == 1) || (xbpm_STATE[p1] == 1))
      return
    TANGO_ERR = ""
    tango_get(xbpm_ADDR,"AcquisitionSpectrum", out)
    if (TANGO_ERR){
      print_tango_err()
      _xbpmdisa(p1)
      return ".error."
    }
    xbpm_CNT[xbpm_ADDR][1] = out[3]
    xbpm_CNT[xbpm_ADDR][2] = out[1]
    xbpm_CNT[xbpm_ADDR][3] = out[2]
    xbpm_CNT[xbpm_ADDR][4] = out[4]
    xbpm_CNT[xbpm_ADDR][5] = out[5]
  }

  if (key == "counts") {
    local mychan myval

    mychan = counter_par(mne,"channel")
    myval = xbpm_CNT[xbpm_ADDR][mychan]
    return myval
  }
}'
#%UU% (unit)
#%MDESC% Enable the %B%unit%B% number counters.
def _xbpmena(unit) '{
local i

  xbpm_STATE[unit] = 0
  for (i in xbpm_CNTNB[unit]) {
    counter_par(xbpm_CNTNB[unit][i], "disable", 0)
  }

}'

#%UU% (unit)
#%MDESC% Disable the %B%unit%B% number counters.
def _xbpmdisa(unit) '{
local i

  for (i in xbpm_CNTNB[unit]) {
    counter_par(xbpm_CNTNB[unit][i], "disable", 1)
  }
}'

#%UU% [unit]
#%MDESC% Disable the %B%unit%B% number counters, all if unit not specified.
def xbpmon '{
local i

  if ($1) {
    xbpm_SIMUL[$1] = 1
    _xbpmdisa($1)
  } else {
    for (i in xbpm_DEV) {
      xbpm_SIMUL[i] = 1
      _xbpmdisa(i)
    }
  }
}'

#%UU% [unit]
#%MDESC% Enable the %B%unit%B% number counters, all if unit not specified.
def xbpmoff '{
local i

  if ($1) {
    xbpm_SIMUL[$1] = 0
    _xbpmena($1)
  } else {
    for (i in xbpm_DEV) {
      xbpm_SIMUL[i] = 0
      _xbpmena(i)
    }
  }
}'

#%UU% [unit X Y Width Height]
#%MDESC% Set a ROI for the BPM %B%unit%B%.
def xbpmroi '{
global xbpm_ROI
local unit i nb_xbpm
  if ($# == 5) {
    unit = $1
    xbpm_ROI[unit][0] = $2
    xbpm_ROI[unit][1] = $3
    xbpm_ROI[unit][2] = $4
    xbpm_ROI[unit][3] = $5
  } else {
    nb_xbpm = 0
    for (i in xbpm_ROIDEV) {
      msg = sprintf ("%s%d ", msg, i)
      nb_xbpm++
      unit=i
    }
    if (nb_xbpm > 1) {
      printf ("Which BPM do you want to use (configured:%s)", msg)
      unit -=1
      unit = getval("", unit)
    }
    printf ("ROI coordinates and size [pixels]:\n")
    xbpm_ROI[unit][0] = getval("\tX coordinate", xbpm_ROI[unit][0])
    xbpm_ROI[unit][1] = getval("\tY coordinate", xbpm_ROI[unit][1])
    xbpm_ROI[unit][2] = getval("\tWidth       ", xbpm_ROI[unit][2])
    xbpm_ROI[unit][3] = getval("\tHeight      ", xbpm_ROI[unit][3])
  }
  if (_xbpmroiset(unit) == -1)
    _xbpmdisa(unit)

}'

#%IU% [unit]
#%MDESC% Get the ROI for all the defined BPMs or the BPM %B%unit%B%.
def xbpmroiget '{
local i

  if ($1)
    _xbpmroiget($1)
  else {
    for (i in xbpm_ROIDEV)
      _xbpmroiget(i)
  }
}'

#%IU% (unit)
#%MDESC% Get the ROI for the BPM %B%unit%B%. 
def _xbpmroiget(unit) '{
local lroi[]

  TANGO_ERR = ""
  tango_get(xbpm_ROIDEV[unit],"image_roi", lroi)
  if (TANGO_ERR){
    print_tango_err()
    return (-1)
  }
  printf ("ROI for %s - unit %1d [pixels]:\n", xbpm_DEV[unit], unit)
  printf ("\tX coordinate: %d\n", lroi[0])
  printf ("\tY coordinate: %d\n", lroi[1])
  printf ("\tWidth       : %d\n", lroi[2])
  printf ("\tHeight      : %d\n", lroi[3])

  return(0)
}'

#%IU% (unit)
#%MDESC% Set a ROI for the BPM %B%unit%B% if needed. 
def _xbpmroiset(unit) '{
global xbpm_ROI
local lroi[] setroi ret

  setroi = 0
  TANGO_ERR = ""
  tango_get(xbpm_ROIDEV[unit],"image_roi", lroi)
  if (TANGO_ERR){
    print_tango_err()
    return (-1)
  }
  for (i in lroi) {
    if (xbpm_ROI[unit][i] != lroi[i]) {
      lroi[i] = xbpm_ROI[unit][i]
      setroi = 1
    }
  }
  ret = 0
  if (setroi)
    ret =tango_put(xbpm_ROIDEV[unit],"image_roi", lroi)
  return(ret)
}'

def _geterr(unit) '{
local myerr[]

  split(TANGO_ERR_STACK["0"]["desc"], myerr, ":")
  if (myerr[0] == "RuntimeError")
    xbpm_STATE[unit] = 1
  else
    xbpm_STATE[unit] = 0
}'


#%MACROS%
#%IMACROS%
#%LOG%
#$Revision: 2.1 $
#$Log: xbpm.mac,v $
#Revision 2.1  2012/10/15 11:09:57  beteva
#correct xbpmroi to handle unit numbers > number of configured BPMs.
#
#Revision 2.0  2012/10/09 16:08:29  beteva
#changed the macro to handle more than one BPM/spec version
#enable/disable counters if the server is not running any more
#enable/disable counters if the GUI is acquiring
#added exposure time set, ROI set
#
#Revision 1.4  2012/05/22 14:50:16  lagier
#added xbpmon and xbpmoff macros.
#
#Revision 1.3  2011/09/28 13:08:29  guijarro
#fixed bug with intensity(need updated server);
#
#Revision 1.2  2011/09/19 07:36:50  domingue
#handle unknown dimension of output array of GetPosition
#
#Revision 1.1  2011/09/16 13:56:21  domingue
#Initial revision
#
#%AUTHOR% mcd september 2011
#%TOC%
